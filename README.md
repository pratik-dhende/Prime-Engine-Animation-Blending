# Prime Engine Animation Blending

## Demo Link
[https://drive.google.com/file/d/1DVvZwMOpaK0VwhlxixcD5SPSbG9Zy4Z4/view?usp=sharing](https://drive.google.com/file/d/1DVvZwMOpaK0VwhlxixcD5SPSbG9Zy4Z4/view?usp=sharing)

## Implementation details
**Note:** *"Palette" itself as a word means the array of joint transforms calculated for the respective animation layer which is supposed to be passed on to the GPU in the context of the implementation details.*
1. Created `struct Vampire` to represent `Vampire`.
1. Created `struct VampireAnimationSM` to manage the animations for the Vampire.
1. Spawned 3 vampires each for demonstrating full body, partial body, and additive animations from the `ClientCharacterControlGame`.
1. Full Body Animation:
    1. The `VampireAnimationSM` handles the events - `Event_SCENE_GRAPH_UPDATE`, `Event_PRE_RENDER_needsRC`, `Event_CALCULATE_TRANSFORMATIONS`.
    1. Assigned key bindings:
        * `1: Set the IDLE LOOK AROUND animation`
        * `2: Set the CROUCH COVER IDLE animation`
    1. The animations are set using the `setAnimation` function.
    1. When the animation is switched, it smoothly blends into the other animation.
1. Partial Body Animation:
    1. Following `DefaultStateMachine` are added to `SkeletonInstance`:
        * `FullBodyAnimationSM for full body animation layer.`
        * `PartialBodyAnimationSM for partial body animation layer.`
    1. The full body animation works as described earlier.
    1. The partial body animation works in the following way:
        1. Each joint is assigned a float value called `mask`. This is done by adding a new member variable called `mask` to `struct JointCPU`.
        1. Following checks are done in the `SkeletonCPU::prepareMatrixPalette()`:
            1. `mask == 0: No animation is performed on that joint.`
            1. `mask == 1: Animation is performed on that joint.`
        1. The above algorithm ensures that only the specific joints are contributing to the animation.
    1. Let,
        * `fullBodyPalette: Final palette generated by the full body animation layer.`
        * `partialBodyPalette: Final palette generated by the partial body animation layer.`
    1. From the `partialBodyPalette`, the joints whose `mask == 1` are taken and are used to replace the respective joints from the `fullBodyPalette` to generate the `finalPalette`.
    1. This `finalPalette` is then sent to GPU.
    1. Full body animation layer uses `IDLE LOOK AROUND` animation.
    1. The partial body animation layer animates just the part below the hips for `FALLING IDLE` animation.
    1. In the final output, the part below the hips of the full body `IDLE LOOK AROUND` animation is replaced with the partial body `FALLING IDLE` below the hips part.
    1. The `VampireAnimationSM` handles the events - `Event_SCENE_GRAPH_UPDATE`, `Event_PRE_RENDER_needsRC`, `Event_CALCULATE_TRANSFORMATIONS`- for both full body and partial body animation layers and sets the appropriate animation for these layers.
1. Additive Animation:
    1. Let,
        * `S: Source Animation Clip = IDLE LOOK AROUND`
        * `R: Reference Animation Clip = IDLE`
        * `D: S - R = Difference`
        * `T: Target clip to which difference is going to be added = FALLING IDLE`
        * `A: Additive animation = T + D = Vampire falling idly and looking around`
    1. The additive animation works in the following way:
        1. The local transforms for the `S` and `R` are calculated in the `SkeletonCPU::prepareMatrixPalette()`.
        1. Let,
            * $S_{l}^{i}$ = `Local transform of ith joint of S at current frame.`
            * $R_{l}^{i}$ = `Local transform of ith joint of R at current frame.`
            * $D_{l}^{i}$ = `Difference of ith joint at current frame.`
            * $T_{l}^{i}$ = `Local transform of ith joint of T at current frame.`
            * $A_{l}^{i}$ = `Local transform of ith joint of A at current frame.`
        1. The difference is calculated at each `ith` joint on each frame: $D_{l}^{i} = S_{l}^{i} \cdot (R_{l}^{i})^{-1}$ 
        1. The additive animation is calculated at each `ith` joint on each frame: $A_{l}^{i} = D_{l}^{i} \cdot T_{l}^{i}$
    1. I have created:
        * `SkeletonCPU::getSourceReferenceDifference(s, r, d)`
            * Calculates the difference local transforms by recursively going through every joint and storing it in `d`.
            * `s, r` arguments are passed to this function as local transforms.
        * `SkeletonCPU::add(t, d, a)`
            * Adds the difference local transforms `d` to the target local transforms `t` by recursively going through each joint and storing it in `a`.
        * `SkeletonCPU::localToModelSpace(local, model)`
            * Takes the `local` space joint transforms and converts them into `model` space joint transforms.
            * Need this method as we are calculating the additive transforms in local space.
            * This method transforms the additive local transforms to its model space transforms to generate the `modelSpacePalette` which is then used to generate the `curPalette` by using the `SkeletonCPU::applyInverses()` function, which is then sent to GPU.
    1. To demonstrate, I have used the following `DefaultAnimationSM` layers, added to the skeletal instance of the vampire:
        * `fullBodyAnimationSourceSM: Generates source local transforms.`
        * `fullBodyAnimationReferenceSM: Generates reference local transforms.`
        * `fullBodyAnimationTargetSM: Generates target local transforms.`
        * `partialBodyAnimationSM: Generates partial body palette.`
        * The final additive animation gives me the output as the vampire falling and looking around simultaneously.
        * I have also used partial body animation for `STOMP R FEET` by animating below the hips part which is then blended with the additive animation output.
        * The final output looks like the vampire looking down and around, and stomping his right foot, all happening simultaneously.
    1. The `VampireAnimationSM` handles the events - `Event_SCENE_GRAPH_UPDATE`, `Event_PRE_RENDER_needsRC`, `Event_CALCULATE_TRANSFORMATIONS`- for these animation layers and sets the appropriate animation for these layers.
    1. The additive animation and final palette calculation are done on `Event_CALCULATE_TRANSFORMATIONS`.
1. `DebugRenderer::createTextMesh()` is used to show debug information for each of the cases and tells which animations are blending to produce the final animation.
1. `DebugRenderer::createTextMesh()` is called on `Event_PRE_RENDER_needsRC`.
1. New animation events and event handlers were created in the `VampireAnimationSM` and are registered in the `GlobalRegistry`.
1. `VampireAnimationSM` is responsible for handling the new animation events for the Vampire by playing those animations.
1. Key bindings are added by creating new events for numerical keys and adding them to the `INPUT` event queue and handled in `DefaultGameControls` by creating the animation events and dispatching them to be finally played by `VampireAnimationSM`.
